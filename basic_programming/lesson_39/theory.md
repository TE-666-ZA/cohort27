# Lesson 39 - 26/06/2023

## 01. Generics

### Вводная задача

* Пусть две модели телефонов - `Nokia3310` и `IPhone`
* Мы решили сделать для них чехлы/обложки
* Мы сделали два класса - `CoverForIPhone` и `CoverForNokia`
* Данные классы специализируются на хранении объекта определенного типа (либо `Nokia3310` либо `IPhone`)
* Классы состоят из трех частей:
  * Поле нужного типа
  * Конструктор, принимающий объект нужного типа и помещающий его в поле
  * Метод-геттер для получения ссылки на сохраненный объект
* Мы понимаем, что структура классов-обложек для айфона и нокии - одинаковые и отличаются только лишь типом, с которым они работают.

### Решение задачи с использованием Object

* Класс Object является предком всех классов
* Соответственно код, который базируется на `Object`, может работать с любыми типами
* Проблема - мы не знаем, какого конкретно типа лежит объект, поэтому, возвращаем `Object`
* Теперь, когда метод-геттер возвращает ссылку типа `Object` в использующем этот метод коде нам необходимо выполнять явное нисходящее преобразование до нужного типа
* Вы должны 100-процентов знать, какого типа объект лежит внутри обложки
* Иначе, мы при явном преобразовании получаем ошибку - `ClassCastException`
* Глобально - мы породили ситуацию, которая потенциально может привести к ошибкам.
* Мы не знаем, что скрывается за `Object`!
* Хотим усидеться на двух стульях - не хотим писать разные классы под разные типы и хотим, чтобы все было безопасно

### Решение с использованием Generics

* Можем рассматривать программу в терминах "неизвестных типов"
* Мы не знаем кого типа будут объекты, но точно знаем, что они будут одного и того же типа.
* `<T>` - обобщение, `<>` - diamonds-оператор, `T` - placeholder 

* В случае для `Cover<T>` - мы не знаем, какого типа будет аргумент конструктора, поле, возвращаемый тип геттера
* Но мы ТОЧНО знаем, что они будут одного и того же типа.
* Они все будут такого-же типа, какой был указан при объявлении объектной переменной.

### Задача на совместное выполнение 

* Научиться пользоваться Generics - научиться хранить пары ключ-значение
* Создали класс-пару "ключ-значение".
* Ключ - может быть любого типа <K>, значение - тоже может быть любого типа <V>

#### Интересные моменты

* Мы можем создать несколько различных пар, у которых будет отличаться значение:

```java
Human marsel = new Human("Марсель", "Сидиков");
Human kenan = new Human("Kenan", "Yusubov");

Pair<String, Human> pair1 = new Pair<>("marselka007", marsel);
Pair<String, Human> pair2 = new Pair<>("эфиоп", kenan);
Pair<String, Scanner> pair3 = new Pair<>("Сканнер", new Scanner(System.in))
```

* Я также могу создать массивы, где укажу, какие пары допускаются к включению:

```
Pair<String, Human>[] pairs = new Pair[3];
Pair<String, Scanner>[] pairs2 = new Pair[2];
```

* Теперь я могу класть в соответствующий массив только допустимые пары:

```
pairs[0] = pair1;
pairs[1] = pair2;
// pairs[2] = pair3; - нельзя, потому что pairs только для String,Human

pairs2[0] = pair3;
// pairs2[1] = pair1; - нельзя, потому что pairs2 только для String,Scanner
```

### А как они на самом деле работают?

* Сначала компилятор проверяет - а не было ли где-нибудь нарушения типов
* Если нарушений не было - срабатывает стирание типов.
* Стирание типов - после компиляции все параметры (K, V, T) - стираются и заменяются на `Object`

### Создание обобщенного массива

* Поскольку T - это не класс, для него нельзя вызывать `new`

```
T[] elements = new T[10] - нельзя!
```

* Можно сначала создать массиво Object-ов, а потом его преобразовать к T[]
```
T[] elements = (T[])new Object[10]
```


## Дополнительный словарик

* Параметризованный тип - Generic
* Параметризовать - сделать из обычного класса Generic
## Словарик

`Casting` - преобразовывать
`Cast` - преобразование
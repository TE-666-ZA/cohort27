# Lesson 35 - 16/06/2023

## 01. Повторение

* Абстрактные классы
  * модификатор `abstract`
  * нельзя создавать объекты
  * могу содержать методы, поля, конструкторы
  * могут содержать абстрактные методы - методы без реализации
  * используются в наследовании
  * содержать какую-то общую часть, которую потомки могу наследовать, переопределять, реализовывать

## 02. Интерфейсы

* Контракт, API (Application Programming Interface), Interface:
  * Есть какие-то модули в приложении, и они могут пользоваться каким-то доступным функционалом друг друга.
  * Набор публичных действий, которые можно делать с этим модулем.
  * В случае простых java-классов - набор публичных методов.

### Рассмотрим задачу

* Есть диспетчер наземного транспорта, он должен иметь возможность одновременно заставить весь транспорт поехать или остановится
* У наземного транспорта есть два метода: `stop()`, `go()`

#### Решение 1

* Сделать абстрактный класс `LandTransport` в котором определим два метода - `stop()` и `go()`
* Далее, каждый тип наземного транспорта обязан в себе реализовать эти два метода.

### Добавляем условие задачи

* Есть диспетчер летающего транспорта, он должен иметь возможность одновременно заставить весь транспорт полететь или приземлиться.

#### Продолжение решения 1

* Создаем абстрактный класс `AirTransport`

![image](https://raw.githubusercontent.com/ait-tr/cohort27/main/basic_programming/lesson_35/img/1.png)

### Проблема контрактов

Есть два пользователя наших классов - `LandTransportDispatcher`, `AirTransportDispatcher`.
Каждый из этих пользователей ждет определенный контракт от классов:
  первый - `go(), stop()`
  второй - `fly(), land()`

Но в java нельзя иметь более одного родителя у одно класса, поэтому сталкиваемся с проблемой,
что классы не могут иметь более одного контракта.

* Интерфейс - технически это класс, который не содержит полей и все его методы абстрактные и публичные.

```
public interface НазваниеИнтерфейса {
  метод1();
  метод2();
}
```

* Интерфейсы не наследуются классами, а имплементируются(реализуются) классами:

```
public class НазваниеКласса implements НазваниеИнтерфейса {
  // ...
}
```

* Класс при имплементации интерфейса, как и с абстрактным классом - обязуется реализовать все методы интерфейса.
* Интерфейс - это контракт, требования к классам, которые его реализуют.
* С интерфейсами также работает правило восходящего преобразования.

```
Интерфейс объектнаяПеременая = объектнаяПеременнаКласса;
```

![image](https://raw.githubusercontent.com/ait-tr/cohort27/main/basic_programming/lesson_35/img.2.png)

### Когда используем интерфейсы, а когда абстрактные классы?

* Абстрактные классы нужны в ситуациях, когда в иерархии необходимо описать какое-либо общее состояние или поведение с готовой реализацией
  * Поля, которые должны быть у всех потомков
  * Методы с реализацией, которые должны быть у всех потомков

* Интерфейсы используются тогда, когда необходимо гарантировать наличие какого-либо поведения (методы).

* Момент с обходом того, что у класса только один предок. - потому что сама задача не подразумевает наличие более одного предка.
* Если вам необходимо, чтобы у класса было более одного предка - значит что-то не так с архитектурой.

![image](https://raw.githubusercontent.com/ait-tr/cohort27/main/basic_programming/lesson_33/img/3.png)

### Проблема ромбовидного наследования

![image](https://raw.githubusercontent.com/ait-tr/cohort27/main/basic_programming/lesson_33/img/4.png)

### Определенные правила именования

* Абстрактные классы начинаются с `Abstract...`
* Классы, которые реализуют какой-либо интерфейс, могу заканчиваться на `Impl`, чтобы показать какие-либо особенности реализации интерфейса.

### Моделирование классов-коллекций через интерфейсы

* `MyList` - интерфейс, описывающий поведение некоторого списка, в который можно класть элементы или получать их по индексу.
* `MyArrayList` - реализация списка на основе массива
* `MyLinkedList` - реализация списка на основе узлов

![image](https://raw.githubusercontent.com/ait-tr/cohort27/main/basic_programming/lesson_33/img/5.png)

### Дополнительно

* `@Override` - проверяет, а правильно ли вы переопределили метод предка
* Интерфейсы можно наследовать, при наследовании интерфейсов методы из интерфейса-предка просто копируются в интерфейс-потомок

### Словарик

* `Air` - воздушный
* `Helicopter` - вертолет
* `Land` - земля, приземлиться
* `Fly` - лететь, муха
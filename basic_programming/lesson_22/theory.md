# Lesson22

## 01. Объектно-ориентированное программирование. Инкапсуляция.

* Иногда нам необходимо описать какую-либо функциональность над какими-нибудь данными. Например - добавление элементов в массив.
* Массив сам по себе не предоставляет такой функциональности. Мы можем просто присваивать элементы по каким-либо индексам.
* Также мы не имеем возможности автоматически его расширять, приходится это писать руками.

```
int a[] = new int[5];
a[0] = 6;
```

### Решение 1

* Создать в main массив и написать процедуры-функции, которые будут с этим массивом как-то работать и выполнять эти операции:

```
public static void main(String[] args) {
    // сам массив, который хранит элементы
    int[] a = new int[5];
    // количество элементов в массиве, которые нас интересуют
    int count = 0;
    
    count = add(a, count, 10);

    if (count == a.length) {
        a = resize(a);
    }
}    
 
public static int[] resize(int[] array) { ... } 

public static int add(int[] array, int count, int element) { ... }
```

* Минусы такого решения: 
  * частично логика в main, частично в функциях, 
  * если нам нужно было бы два массива, пришлось бы дублировать `count`
  * нет возможности контролировать корректность данных, например, адекватность count и заполненность массива
  * весь код превращается в набор процедур, которые вызывают сами себя или другие процедуры, нет никакого контроля и читаемость сильно падает

* Немного истории - подход, который описан выше, называется процедурной парадигмой программирования (процедурный стиль).

### Решение 2

* Используем объектно-ориентированный подход (ООП-стиль, объектно-ориентированную парадигму)

* Создаем класс с необходимыми полями (количество элементов массива и сам массив), делаем их приватными, чтобы снаружи нельзя было изменить их состояние
* Это дало возможность создавать сколько угодно таких массивов.

```
public class MyArray {
    private int count; 
    private int[] array;
    
    // ...
}
```

* Далее, поскольку поля известны всем методам внутри класса, то мы можем написать методы, работающие с этими полями, например для увеличения или добавления:

```
public class MyArray {
    // ...
    
    public void add(int element) { ... }
    private void resize() { ... }
}
```

* Поскольку у вас поля полностью закрыты от внешнего доступа, то для поля `count` мы написали метод getter (геттер) для получения информации о поле:

```
public class MyArray {

    // ...
    
    public int getCount() {
        return count;
    }
}
```

* Полученный результат:

![image](https://raw.githubusercontent.com/ait-tr/cohort27/main/basic_programming/lesson_22/img/4.png)


* Резюмируя, мы описали новый тип данных `MyArray`, который содержит в себе логику хранения данных и само хранилище данных.
* Таким образом, класс - это сочетание состояния (например, поля - `count`, `array`) и поведения (например, `add()`, `resize()`, `getCount`)
* Инкапсуляция ("в капсуле") - второй принцип ООП:
  * Возможность сочетать в одной сущности (классе) состояние (поля) и поведение (методы)
  * Возможность закрывать доступ к внутренней структуре класса (использование `private`)


* `private` - модификатор доступа (уровень доступа - закрытый), который запрещает манипуляции с членом класса (полем) из других классов
* `public` - модификатор доступа (уровень доступа - открытый), который открывает доступ к члену класса отовсюду
* отсутствие модификатора - уровень доступа - пакетный, член класса доступен всем другим классам внутри пакета

### Алгоритмы, используемые при работе с массивом:

* Добавление элемента в массив:

![image](https://raw.githubusercontent.com/ait-tr/cohort27/main/basic_programming/lesson_22/img/1.png)

* Создание нового массива при переполнеии:

![image](https://raw.githubusercontent.com/ait-tr/cohort27/main/basic_programming/lesson_22/img/2.png)

* Плохая реализация `resize` с попыткой изменения ссылки внутри функции:

![image](https://raw.githubusercontent.com/ait-tr/cohort27/main/basic_programming/lesson_22/img/3.png)

## Словарик

* `Resize` - изменить размер
* `get` - получить
* `private` - приватный
* `public` - публичный
* `Access mode` - уровень доступа
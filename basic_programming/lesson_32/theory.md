## 01. Правила наследования

* При наследовании всегда должно соблюдаться правило, что потомок - частный случай предка.
* Человек -> Программист, программист - это частный случай человека.
* Потомки всегда делаются более специализированными.
* Нельзя менять семантическое значение полей и методов
* Была проблема:
  - Вы использовали координаты центра как стороны-радиусы эллипса или прямоугольника
  - Эллипс и Прямоугольник не должны наследоваться друг от друга
  - Круг - это частный случай Эллипса, а квадрат - это частный случай прямоугольника

## 02. Перегрузка и переопределение

* Перегрузка (`Overload`) - вы можете использовать методы или конструкторы в одном классе с одинаковыми названиями, но разными формальными параметрами.
* Перегруженными методами не могут быть методы:
  * у которых отличается только тип возвращаемого значения
  * у которых отличается только названия аргументов

* Переопределение (`Override`) - это когда в классе-потомке метод полностью повторяет сигнатуру метода в классе предке, но имеет другую реализацию
* Метод не является переопределенным, если у него изменена сигнатура в потомке

## 03. Восходящее преобразование

* Вы можете присвоить объектной переменной типа предка адрес объекта типа потомка.
* Предок ссылается на потомка. 
* Переменная имеет тип предка, но указывает она на объект потомка.
* При этом сам объект не меняется, на него просто указывает переменная другого типа.
* Через переменную типа предка нельзя вызывать методы потомка (если их нет у предка), потому что переменная вас ограничивает только теми членами, которые есть у предка.
* Если через переменную типа предка, которая указывает на объект потомка, вызвать метод, переопределенный в потомке - будет вызвана реализация потомка.

![image](https://raw.githubusercontent.com/ait-tr/cohort27/main/basic_programming/lesson_32/img/1.png)

## 04. Полиморфизм

* Механизм, при котором с объектами разных типов можно работать так, как если бы они принадлежали одному типу называется - полиморфизм.
* Полиморфизм - четвертый и самый важный принцип ООП
* Достигается за счет наследования и восходящего преобразования
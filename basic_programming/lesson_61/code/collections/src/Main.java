public class Main {

  // String как коллекция символов - неизменяемая (не можем менять содержимое),
  //   упорядоченная (есть индексы)
  // - получение элемента по индексу:
  //   O(1) - адрес начала + индекс
  // array (int[]) - постоянный размер, упорядоченная
  // - получение или изменение (обращение к) элемента по индексу:
  //   O(1) - адрес начала + индекс
  // List
  // ArrayList - упорядоченная
  // - добавление элемента
  //   - в конец - O(1), иногда O(n)
  //   - в начало и середину - O(n / 2) = O(0.5 * n) = O(n)
  //   - по итератору - O(n)
  // - обращение по индексу
  //   O(1) - как в array
  // - удаление элемента
  //   - из конца - O(1)
  //   - из начала и середины - O(n)
  // LinkedList
  // - добавление элемента
  //   - в начало - O(1)
  //   - по итератору - O(1)
  //   - в середину - O(n) для поиска
  //   - в конец - O(1) (теоретически O(n) для поиска)
  // - обращение по индексу
  //   - O(n)
  //   - по итератору - O(1)
  // - удаление элемента
  //   - из начала - O(1)
  //   - по итератору - O(1)
  //   - из середины - O(n) для поиска
  //   - из конца - O(1) (теоретически O(n) для поиска)
  // Set
  // HashSet - требуется hashCode - неупорядоченная, без повторения элементов
  //   проверяем hash, при одинаковом - сравниваем
  // - добавление
  // - поиск (проверка существования)
  // - удаление
  //   - подсчёт хэша - O(1), но может быть долгим. Для строк O(length)
  //   - выбор ведёрка с таким же хэшем - O(1)
  //   - сравнение с остальным содержимым - O(bucket_size)
  //   в самом плохом случае (для плохих хэш-функций) превращается в O(n)
  //     и ведёт себя как ArrayList с линейным поиском
  // TreeSet - требуется Comparable или Comparator - упорядоченная, без повторения элементов
  //   всегда хранит элементы отсортированными по возрастанию
  //   новое место или существующий элемент всегда ищутся бинарным поиском - O(log n)
  //   |----------------| - размер n
  //            |-------| - размер меньше в 2 раза
  //            |---|     - размер меньше в 2 раза
  //              |-|     - размер меньше в 2 раза
  //              |       - размер 1
  //   сложность: сколько раз надо n разделить на 2, чтобы получить 1
  //     сколько раз надо 1 умножить на 2, чтобы получить n
  //     1 * 2 * 2 * 2 ... * 2 = n   - количество двоек
  //         2 * 2 * 2 ... * 2 = n   - количество двоек
  //                     2 ^ k = n   - k (степень двух)
  //     A ^ P = R       - A в степени P равно R
  //     логарифм - это степень, в которую нужно возвести основание, чтобы получить аргумент
  //     логарифм по основанию A от аргумента R равен P
  //     2 ^ k = n
  //     логарифм - это степень, в которую нужно возвести основание, чтобы получить аргумент
  //     k        - это степень, в которую нужно возвести 2,         чтобы получить n
  //     логарифм по основанию 2 от n равен k
  //     k = log2(n)
  //     log_a(b) = log b / log a (где log - натуральный или десятичный)
  //     k = log2(n) = log n / log 2 = c * log n = O(log n)
  // - добавление
  // - поиск (проверка существования)
  // - удаление
  //   O(log n)
  // Map
  // HashMap
  // - ключи как в HashSet
  // TreeMap
  // - ключи как в TreeSet
  public static void main(String[] args) {
    System.out.println("Hello world!");
  }
}
